# Alias System - Architecture and Configuration

## Overview

Our monorepo uses a consistent alias system to eliminate relative paths and enable uniform imports across all contexts. This document serves as a complete guide for setting up aliases in any package or app.

## Types of Aliases

### 1. Internal Aliases (`@/*`)

**Usage:** Internal functions of the current package/app
**Example:** `import { myFunction } from '@/utils/logger';`

**Configuration:**

- Defined in each package/app's `tsconfig.json`
- Point to `src/*` of the current package/app
- Work in dev (Vite) and build (esbuild/TypeScript)

### 2. Inter-Package Aliases (`@vite-powerflow/*`)

**Usage:** Functions from other packages in the monorepo
**Example:** `import { exampleFunction } from '@vite-powerflow/example-package';`

**Configuration:**

- Automatically generated by `scripts/generate-vite-aliases.cjs`
- Defined in `tsconfig.base.json` and `vite.aliases.json`
- Point to `packages/*/dist/`

## âš ï¸ Critical Distinction: Internal vs Inter-Package Aliases

### Internal Aliases (`@/*`)

- **Purpose:** Import functions from the **current package's** `src/` directory
- **Scope:** Local to the package/app where the import is written
- **Example:** In `packages/utils/src/`, `@/utils/foo` points to `packages/utils/src/utils/foo.ts`
- **When to use:** For importing your own utilities within the same package

### Inter-Package Aliases (`@vite-powerflow/*`)

- **Purpose:** Import functions from **other packages** in the monorepo
- **Scope:** Cross-package imports (sharing code between packages)
- **Example:** `@vite-powerflow/shared-utils` points to `packages/shared-utils/dist/index.js`
- **When to use:** For importing utilities from a different package

### âŒ Common Mistake

**Never use `@utils` (without the slash) for internal imports!**

- `@utils/foo` âŒ (ambiguous - could be internal or external)
- `@/utils/foo` âœ… (clearly internal)
- `@vite-powerflow/shared-utils` âœ… (clearly external package)

## System Architecture

```
Monorepo
â”œâ”€â”€ packages/
â”‚   â”œâ”€â”€ example-package/
â”‚   â”‚   â”œâ”€â”€ tsconfig.json (internal aliases: @/*)
â”‚   â”‚   â”œâ”€â”€ build.js (esbuild with alias resolution)
â”‚   â”‚   â””â”€â”€ src/
â”‚   â””â”€â”€ shared-utils/
â”‚       â”œâ”€â”€ tsconfig.json (internal aliases: @/*)
â”‚       â””â”€â”€ src/
â”œâ”€â”€ apps/
â”‚   â”œâ”€â”€ starter/
â”‚   â”‚   â”œâ”€â”€ tsconfig.json (internal aliases: @/*)
â”‚   â”‚   â””â”€â”€ src/
â”‚   â””â”€â”€ example-app/
â”‚       â”œâ”€â”€ tsconfig.json (internal aliases: @/*)
â”‚       â””â”€â”€ src/
â”œâ”€â”€ tsconfig.base.json (inter-package aliases)
â””â”€â”€ vite.aliases.json (Vite aliases)
```

## Setup Instructions for AI

### When creating a new Package (`packages/*/`)

1. **Create `tsconfig.json` with internal aliases:**

```json
{
  "include": ["src"],
  "compilerOptions": {
    "target": "ES2022",
    "module": "ESNext",
    "moduleResolution": "node",
    "allowImportingTsExtensions": false,
    "resolveJsonModule": true,
    "strict": true,
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "skipLibCheck": true,
    "declaration": true,
    "declarationMap": true,
    "emitDeclarationOnly": false,
    "noEmit": false,
    "outDir": "dist",
    "rootDir": "src",
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"],
      "@/utils/*": ["src/utils/*"]
    }
  }
}
```

2. **Create `build.js` for esbuild (required for alias resolution):**

```javascript
import * as esbuild from 'esbuild';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

(async () => {
  await esbuild
    .build({
      entryPoints: ['src/index.ts'],
      bundle: true,
      platform: 'node',
      target: 'node18',
      outdir: 'dist',
      format: 'esm',
      external: [],
      alias: {
        '@/*': path.resolve(__dirname, 'src/*'),
        '@/utils/*': path.resolve(__dirname, 'src/utils/*'),
      },
      sourcemap: true,
      minify: false,
    })
    .then(() => {
      console.log('âœ… Package built successfully with esbuild');
    })
    .catch(error => {
      console.error('âŒ Package build failed:', error);
      process.exit(1);
    });
})();
```

3. **Update `package.json` build script:**

```json
{
  "scripts": {
    "build": "node build.js && tsc --emitDeclarationOnly --outDir dist",
    "clean": "rm -rf dist"
  },
  "devDependencies": {
    "esbuild": "^0.25.6"
  }
}
```

4. **Add package to dependencies in apps that use it:**

```json
{
  "dependencies": {
    "@vite-powerflow/your-package": "workspace:*"
  }
}
```

### When creating a new App (`apps/*/`)

1. **Create `tsconfig.json` with internal aliases:**

```json
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable", "WebWorker"],
    "module": "ESNext",
    "skipLibCheck": true,
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "react-jsx",
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"],
      "@/assets/*": ["src/assets/*"],
      "@/components/*": ["src/components/*"],
      "@/context/*": ["src/context/*"],
      "@/lib/*": ["src/lib/*"],
      "@/pages/*": ["src/pages/*"],
      "@/store/*": ["src/store/*"],
      "@/tests/*": ["tests/*"],
      "@/types/*": ["src/types/*"],
      "@/utils/*": ["src/utils/*"]
    },
    "types": ["vitest/globals", "@testing-library/jest-dom"]
  },
  "extends": "../../tsconfig.base.json",
  "include": ["src"],
  "exclude": ["node_modules"]
}
```

2. **Add package dependencies if needed:**

```json
{
  "dependencies": {
    "@vite-powerflow/example-package": "workspace:*"
  }
}
```

## Exporting Public API from a Package

To make functions, classes, or constants available to other packages or apps, **you must explicitly export them in your packageâ€™s `src/index.ts` file**.

**Example:**

```ts
// src/utils/math.ts
export function add(a: number, b: number) {
  return a + b;
}

// src/index.ts
export { add } from './utils/math.js';
```

- Only what you export from `src/index.ts` will be accessible via:
  ```ts
  import { add } from '@vite-powerflow/your-package';
  ```
- Helpers not exported from `index.ts` remain private to the package.

**This is not automated by TypeScript or Node. You control your packageâ€™s public API via `index.ts`.**

> **Note:** This process can be automated using "barrel" file generators (e.g., [barrelsby](https://github.com/bencoveney/barrelsby)), but manual control is recommended for clarity and to avoid exposing internal helpers unintentionally.

---

## Required Configuration

### For each Package (`packages/*/tsconfig.json`)

```json
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"],
      "@/utils/*": ["src/utils/*"]
    }
  }
}
```

### For each App (`apps/*/tsconfig.json`)

```json
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"],
      "@/utils/*": ["src/utils/*"],
      "@/components/*": ["src/components/*"],
      "@/lib/*": ["src/lib/*"]
    }
  }
}
```

### Global Configuration (`tsconfig.base.json`)

```json
{
  "compilerOptions": {
    "paths": {
      "@vite-powerflow/example-package": ["packages/example-package/dist/index.js"],
      "@vite-powerflow/shared-utils": ["packages/shared-utils/dist/index.js"]
    }
  }
}
```

## Automatic Generation

The `scripts/generate-vite-aliases.cjs` script:

1. Scans all packages in `packages/`
2. Generates inter-package aliases in `tsconfig.base.json`
3. Generates Vite aliases in `vite.aliases.json`
4. Updates TypeScript references in `tsconfig.json`

**Important:** The script only generates inter-package aliases, not internal aliases (configured manually).

## Development Workflow

### In a Package

```typescript
// Internal alias (resolved by esbuild)
import { internalUtil } from '@/utils/helper';

// Inter-package alias (resolved by Vite/TypeScript)
import { externalUtil } from '@vite-powerflow/shared-utils';

export function myFunction() {
  return internalUtil() + externalUtil();
}
```

### In an App

```typescript
// Internal alias (resolved by Vite)
import { appUtil } from '@/utils/logger';

// Inter-package alias (resolved by Vite)
import { packageUtil } from '@vite-powerflow/example-package';

export function appFunction() {
  appUtil();
  return packageUtil();
}
```

### ðŸ“ Quick Reference

| Import Type       | Alias Pattern                  | Example                                              | Points To                             |
| ----------------- | ------------------------------ | ---------------------------------------------------- | ------------------------------------- |
| **Internal**      | `@/utils/foo`                  | `import { foo } from '@/utils/foo'`                  | Current package's `src/utils/foo.ts`  |
| **Inter-package** | `@vite-powerflow/shared-utils` | `import { foo } from '@vite-powerflow/shared-utils'` | `packages/shared-utils/dist/index.js` |
| **âŒ Wrong**      | `@utils/foo`                   | `import { foo } from '@utils/foo'`                   | Ambiguous/undefined                   |

## Environments

### Development (Vite)

- **Internal aliases:** Resolved by Vite + TypeScript
- **Inter-package aliases:** Resolved by Vite + TypeScript
- **No build** required

### Build (Packages - esbuild)

- **Internal aliases:** Resolved by esbuild and compiled to real paths
- **Inter-package aliases:** Resolved by esbuild and compiled to real paths
- **Runtime:** Node.js executes JavaScript without aliases

### Build (Apps - Vite)

- **Internal aliases:** Resolved by Vite and compiled to real paths
- **Inter-package aliases:** Resolved by Vite and compiled to real paths
- **Runtime:** Browser executes JavaScript without aliases

### Runtime (Node.js)

- **All aliases:** Compiled to real paths
- **Imports:** Resolved via `package.json` exports

## Critical Notes for AI

1. **Packages MUST use esbuild** for build (not just TypeScript) to resolve internal aliases
2. **Apps use Vite** for build which handles aliases automatically
3. **Internal aliases** must be configured manually in each `tsconfig.json`
4. **Inter-package aliases** are generated automatically by the script
5. **Dependencies** must be declared in `package.json` for inter-package imports
6. **esbuild is required** as devDependency for packages that use internal aliases

## Troubleshooting

### "Cannot find module" Error

1. Check that the alias is defined in the correct `tsconfig.json`
2. Check that the package is built (`dist/` exists)
3. Check that the dependency is declared in `package.json`
4. For packages: ensure `build.js` uses esbuild with alias configuration
5. For apps: ensure Vite is configured with `vite-tsconfig-paths`

### Aliases not resolved in dev

1. Check Vite configuration (`vite.config.ts`)
2. Check that `vite-tsconfig-paths` is installed
3. Restart the dev server

### Build fails

1. Check that all packages are built
2. Check TypeScript configuration
3. Run `pnpm generate:aliases` again
4. For packages: ensure esbuild is installed and `build.js` is configured

### Package build fails with aliases

1. Ensure `build.js` exists and uses esbuild
2. Check that esbuild is in devDependencies
3. Verify alias configuration in `build.js` matches `tsconfig.json`
4. Ensure `package.json` build script calls `node build.js`

## Import Extensions: Best Practices & Subtleties

### TypeScript Source (including tests)

- **Never use file extensions** in imports (no `.js`, `.ts`, etc.).
- Example:
  ```ts
  import { foo } from './foo';
  import { bar } from '@/utils/bar';
  import { baz } from '@vite-powerflow/utils';
  ```
- TypeScript resolves the correct file automatically.
- If you use `.js` in a TypeScript import, it will fail in dev/test (file not found).

### JavaScript ESM (Node, Vite, etc.)

- **Use the extension** (usually `.js`) in imports:
  ```js
  import { foo } from './foo.js';
  ```
- Node ESM and some bundlers require the extension.

### Inter-Package Imports in Monorepo

- **TypeScript:** Use the package alias without extension:
  ```ts
  import { foo } from '@vite-powerflow/shared-utils';
  ```
- **JavaScript ESM:** Use the extension if required by the runtime:
  ```js
  import { foo } from '@vite-powerflow/shared-utils/index.js';
  ```

### Local Aliases (within a package/app)

- Always use the alias (e.g. `@/utils/xxx`) or relative path **without extension** in TypeScript.

### Tests (Vitest, Jest, etc.)

- Always import **without extension** in TypeScript tests:
  ```ts
  import { foo } from '@/utils/bar';
  ```
- If you use `.js`, the test runner will not find the file (unless you build first, which is not the dev/test workflow).

### Summary Table

| Context                | Extension in import? | Example                                                       |
| ---------------------- | :------------------: | ------------------------------------------------------------- |
| TypeScript source      |      âŒ (never)      | `import { foo } from './foo'`                                 |
| JavaScript ESM         |      âœ… (often)      | `import { foo } from './foo.js'`                              |
| Tests TypeScript       |      âŒ (never)      | `import { foo } from '@/utils/bar'`                           |
| Inter-package (TS)     |      âŒ (never)      | `import { foo } from '@vite-powerflow/shared-utils'`          |
| Inter-package (JS ESM) |   âœ… (if required)   | `import { foo } from '@vite-powerflow/shared-utils/index.js'` |

**Rule of thumb:**

> In TypeScript (including tests), never use an extension in imports. Only use extensions in JavaScript ESM if the runtime requires it.
