# AI Commit Process Rules

## 1. Commit Workflow

When the user requests to make a commit, the AI must:

1. Automatically analyze all staged changes using `git diff --cached`.
2. Propose the most relevant commit plan (grouped or atomic) based on the nature and scope of the changes, prioritizing clarity and maintainability.
3. For each planned commit, present an example with the commit title (header) and body (Conventional Commit format).
4. Wait for user validation of the proposed commits. If validated, execute the commits as planned without further questions.
5. Never include unstaged files in a commit unless the user explicitly requests it. Only files that are currently staged will be included in the commit.

## 2. Commit Message Guidelines (Format & Readability)

- All commit messages must follow the Conventional Commit format.
  - Allowed types: build, chore, ci, docs, feat, fix, perf, refactor, revert, style, test.
  - The header (first line) must be ≤ 72 characters, imperative mood, no period at the end.
  - The body (optional) must be ≤ 100 characters per line, each line a complete thought.
  - Use bullet points in the body for multiple changes.
  - All commit messages and comments must be written in English.
- Commit messages must be readable and understandable by anyone reviewing the history, even without detailed knowledge of the code.
- Each message must:
  - Clearly describe the scope and purpose of the change (what is changed and why it matters).
  - Explicitly mention the technical elements impacted (e.g., module names, scripts, templates, configs, etc.).
  - Avoid raw file lists or overly generic descriptions.
- The assistant must always prioritize clarity, readability, and technical context in commit message writing.
